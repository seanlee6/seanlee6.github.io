---
layout:     post
title:      从一道面试题记贪婪算法
subtitle:   贪婪算法
date:       2020-05-14
author:     SeanLee
header-img: img/404-bg.jpg
catalog: true
tags:
    -JAVA  -贪婪算法
---


## 前言

招商银行Fintech实习笔试题


## 正文

上闲来无事参加招商银行的实习笔试题，没想到结果竟然意外地有趣，上来就是三道竞赛题，第一题平平无奇，第二道就是情侣牵手的题目，虽然不一样后面在刷leecode的时候看到一题类似的，就记录一下做法。

题目：N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。

人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。

这些情侣的初始座位  row[i] 是由最初始坐在第 i 个座位上的人决定的。

示例 1:

输入: row = [0, 2, 1, 3]
输出: 1
解释: 我们只需要交换row[1]和row[2]的位置即可。
示例 2:

输入: row = [3, 2, 0, 1]
输出: 0
解释: 无需交换座位，所有的情侣都已经可以手牵手了。

因为已经给情侣编好了位置，所以说用数组对来表示情侣，12345这样。于是我们假设N个沙发，12345N-1，N。这样的话，如果一次交换后，没有完成任务，那么这次的交换肯定是不成功的。不是最优解。

思路：由于我们每按照顺序让每个沙发的情侣能配对，那么我们先找沙发上第一个人的情侣，如果不在一个沙发，就将其换成情侣。
算法：将其编号为X，那么他的情侣的编号为 x ^ 1， ^ 在这里是异或操作。对于每张沙发上的第一个人 x = row[i]，找到他们的同伴所在的位置 row[j]，将 row[j] 和 row[i + 1] 互相交换。

```objc
class Solution {
    public int minSwapsCouples(int[] row) {
        int ans = 0;
        for (int i = 0; i < row.length; i += 2) {
            int x = row[i];
            if (row[i+1] == (x ^ 1)) continue;
            ans++;
            for (int j = i+1; j < row.length; ++j) {
                if (row[j] == (x^1)) {
                    row[j] = row[i+1];
                    row[i+1] = x^1;
                    break;
                }
            }
        }
        return ans;
    }
}
```
复杂度分析

时间复杂度: O(N^2)其中N为情侣对的数量。

空间复杂度: O(1)，互相交换不需要开辟额外的空间。


### 贪婪算法

所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。
贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。）
所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。

贪心选择
贪心选择是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。贪心选择是采用从顶向下、以迭代的方法做出相继选择，每做一次贪心选择就将所求问题简化为一个规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择的性质，我们必须证明每一步所作的贪心选择最终能得到问题的最优解。 通常可以首先证明问题的一个整体最优解，是从贪心选择开始的，而且作了贪心选择后，原问题简化为一个规模更小的类似子问题。然后，用数学归纳法证明，通过每一步贪心选择，最终可得到问题的一个整体最优解。

解题的一般步骤是：
1.建立数学模型来描述问题；
2.把求解的问题分成若干个子问题；
3.对每一子问题求解，得到子问题的局部最优解；
4.把子问题的局部最优解合成原来问题的一个解。


### 例题

例题方面可以参考hust_chen博客中所总结的一些算法导论中的标准题型：https://www.cnblogs.com/hust-chen/p/8646009.html
<<<<<<< HEAD
其中较为经典的就是POJ1700中的过河问题：问题链接如下：http://poj.org/problem?id=1700
问题的大致意思就是n个人需要过河，每个人过河时间不同，但是船每次最多只能带两个过河，时间取决于长的那个时间。需要安排过河方案，让所有人最短时间过河。


解题思路：当人数达到了3个人以上的话主要分为两种情况：
假设n个人单独过河所需要的时间存储在数组t中,将数组t按升序排序,那么 这时将单独过河所需要时间最多的两个旅行者送到对岸去,有两种方式
1.最快的和次快的过河，然后最快的将船划回来；次慢的和最慢的过河，然后次快的将船划回来，所需时间为：t[0]+2*t[1]+t[n-1]；
2.最快的和最慢的过河，然后最快的将船划回来，最快的和次慢的过河，然后最快的将船划回来，所需时间为：2*t[0]+t[n-2]+t[n-1]。


=======

其中较为经典的就是POJ1700中的过河问题：问题链接如下：http://poj.org/problem?id=1700

问题的大致意思就是n个人需要过河，每个人过河时间不同，但是船每次最多只能带两个过河，时间取决于长的那个时间。需要安排过河方案，让所有人最短时间过河。


解题思路：当人数达到了3个人以上的话主要分为两种情况：
假设n个人单独过河所需要的时间存储在数组t中,将数组t按升序排序,那么 这时将单独过河所需要时间最多的两个旅行者送到对岸去,有两种方式
1.最快的和次快的过河，然后最快的将船划回来；次慢的和最慢的过河，然后次快的将船划回来，所需时间为：t[0]+2*t[1]+t[n-1]；
2.最快的和最慢的过河，然后最快的将船划回来，最快的和次慢的过河，然后最快的将船划回来，所需时间为：2*t[0]+t[n-2]+t[n-1]。


>>>>>>> ea687eb3c83fa1782b340e750baca63bfb83eebc
```objc
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    int m,n,t[1001],i,sum;
    cin>>m;
    while(m--)
    {
        cin>>n;
        sum=0;
        for(i=0;i<n;i++)
            cin>>t[i];
        sort(t,t+n);
        for(i=n-1;i>2;i-=2)
            if(t[0]+2*t[1]+t[i]>2*t[0]+t[i-1]+t[i])
                sum+=2*t[0]+t[i-1]+t[i];
            else sum+=t[0]+2*t[1]+t[i];
            if(i==2) sum+=t[0]+t[1]+t[2];
            else if(i==1) sum+=t[1];
            else sum+=t[0];
            cout<<sum<<endl;
    }
    return 0;
}
```


